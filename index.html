<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Браузерная рисовалка</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222; /* Потемнее фон */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: 'Arial', sans-serif; /* Шрифт без засечек */
      color: white;
    }

    canvas {
      border: 2px solid gray;
    }

    #drawCanvas {
      cursor: crosshair;
    }

    p {
      font-size: 24px; /* Увеличенный размер шрифта */
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="drawCanvas" width="400" height="400"></canvas>
  <p id="resultText">Нарисуйте цифру от 0 до 9.</p>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('drawCanvas');
      const ctx = canvas.getContext('2d');

      // Set initial styles
      ctx.fillStyle = 'white';
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 16;

      let isDrawing = false;

      // Function to draw on the canvas
      function draw(e) {
        if (!isDrawing) return;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop, ctx.lineWidth / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
      }

      // Event listeners for drawing
      canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
          isDrawing = true;
          ctx.beginPath();
          draw(e);
        }
      });

      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', () => {
        if (isDrawing) {
          isDrawing = false;
          sendCanvasData();
        }
      });
      canvas.addEventListener('mouseout', () => {
        if (isDrawing) {
          isDrawing = false;
          sendCanvasData();
        }
      });

      // Touch events for mobile devices
      canvas.addEventListener('touchstart', (e) => {
        isDrawing = true;
        ctx.beginPath();
        draw(e.touches[0]);
      });

      canvas.addEventListener('touchmove', (e) => {
        draw(e.touches[0]);
        e.preventDefault();
      });

      canvas.addEventListener('touchend', () => {
        if (isDrawing) {
          isDrawing = false;
          sendCanvasData();
        }
      });

      // Function to send canvas data to the backend
      function sendCanvasData() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const compressedData = compressImage(imageData, 28, 28);
        const flattenedData = flattenImageData(compressedData);
        const jsonData = JSON.stringify(flattenedData);

        // Replace the following URL with your backend endpoint
        const backendURL = 'http://localhost:5000/predict';

        // Example Ajax request using fetch
        fetch(backendURL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: jsonData
        })
        .then(response => response.json())
        .then(data => {
          displayResult(data.number);
        })
        .catch(error => console.error('Error:', error));
      }

      // Function to compress the image to the specified dimensions
      function compressImage(imageData, targetWidth, targetHeight) {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        tempCanvas.width = targetWidth;
        tempCanvas.height = targetHeight;

        // Draw the original image onto the temporary canvas with the new dimensions
        tempCtx.drawImage(
          canvas,
          0,
          0,
          imageData.width,
          imageData.height,
          0,
          0,
          targetWidth,
          targetHeight
        );

        // Get the new image data from the temporary canvas
        return tempCtx.getImageData(0, 0, targetWidth, targetHeight);
      }

      // Function to flatten the image data into an array
      function flattenImageData(image) {
        const flattenedData = [];

        for (let y = 0; y < image.height; y++) {
          for (let x = 0; x < image.width; x++) {
            const index = (y * image.width + x) * 4;
            const grayscaleValue = (image.data[index] + image.data[index + 1] + image.data[index + 2]) / 3;
            flattenedData.push(grayscaleValue);
          }
        }

        return flattenedData;
      }

      // Function to display the result
      function displayResult(number) {
        const resultText = document.getElementById('resultText');
        resultText.textContent = `Я думаю, что ты нарисовал: ${number}`;
      }
    });
  </script>
</body>
</html>
